---
layout: single
title: "Big-O 표기법과 시간/공간복잡도"
category: Algorithm
tags: [Algorithm]
date: 2024-01-07
comments: true
---

## 빅오표기법

입력의 크기가 커짐에 따라 실행 시간이 어떻게 증가하는지 표기하는 방법
식에 붙어있는 계수가 아닌, 차수를 기준으로 표기한다.

## 예시 및 크기 차이

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) ...

## 계산 예시

- 1부터 N까지의 덧셈.
  - 반복문을 통한 계산
    ```python
    i = 0
    n = 5
    for idx in range(i, n + 1):
      i = i + idx
    ```
    - idx가 Range에 드는지에 대한 계산 1번
    - i에 idx를 계산하는 연산 한 번
    - i에 위에서 계산한 값을 적용한 연산 총 1번
    - 그래서 3N번의 연산을 할 슈 있다는 것을 알 수 있고, 이를 표기하면 O(N) 으로 표햔할 수 있다.
  - 공식을 통한 계산
    ```python
    i = 0
    n = 5
    sum = n * (n + 1) / 2
    ```
    - N에 상관없이 연산은 3번
    - O(1)의 시간복잡도를 가짐

## 시간복잡도 계산을 통해 문제 풀이 방법을 어림짐작할 수 있는 방법

컴퓨터는 **1초동안 약 1억번**의 연산을 한다고 생각하면 된다.

- 시간제한이 2초, 시간복잡도가 O(NM)이고, N이 1000, M이 10000일 경우
  - 최대 연산량은 1000 \* 10000 = 1000,0000 -> 천만이므로, NM의 시간복잡도로 풀 수 있는 문제이다.
- 시간제한이 2초, N이 100000, M이 100000일 경우
  - 100000 \* 100000 = 100,0000,0000 -> 100억번이므로 NM의 시간복잡도로 풀 수 없다.
  - O(NlogM)의 시간복잡도로 풀 경우
    - 5(log100000) / 0.3(log2) = 16.666
    - 100000 \* 16.6 = 1600000 번으로 줄어들기 때문에 넉넉하게 시간 복잡도 안에 들어오는 것을 알 수 있다.

## 공간복잡도

문제를 풀 때 필요한 메모리의 양

## BigO로 계산하는 공간복잡도

```python
n = 5
a = [1, 2, 3, 4, 5]
x = 0
for idx in range(0, n):
  x = x + idx
```

- 이 때 필요한 양은 (4 \* N)(a) + 4(n) + 4(x) + 4(idx) = 4N + 12의 양이 필요함.
- N에 따라 선형적으로 공간이 증가하기 때문에 O(N)만큼 차지하게 된다.
