---
layout: single
title:  "Python으로 구현하는 BFS"
category: Algorithm
tags: [Algorithm, Python, BFS]
date: 2023-03-05
comments : true
---

요즘 회사 일이 많이 바빠 기록이 뜸했었습니다.
다시 시작하려니 막막해서 키보드를 잡는데도 생각보다 오랜 시간이 걸렸습니다.

주기적으로 스터디원들과 같이 알고리즘 몇 문제를 풀고 있는데 공부를 좀 놓으니 바로 뒤쳐지는게 느껴지더라구요.
이 문제의 이론은 알고 있는 부분인데, 기억이 안나서 몇 번이나 다시 보게 되고, 문제는 안풀리고의 반복이라 점점 흥미를 잃어가고의 무한 굴레가 반복되는 상황이 지속되었습니다.

찬찬히 이에 대해 생각을 해봤고, 결론은 아래와 같았습니다.

언제든지 이런 상황은 다시 생길 수 있다.
이러한 사정으로 다시 놓게 됐을 때, 정리한 포스팅이 있다면, 다시 시간이 생겼을 때 그 정리한 내용을 읽는다면, 좀 더 쉽게 복귀할 수 있지 않을까?

그래서 공부했던 내용을 하나하나 정리를 해 보려고 합니다.

<br>

## BFS(Breadth First Algorithm)란?
시작 노드에서 가장 가까운 노드 부터 완전 탐색하는 알고리즘을 지칭합니다.
![BFS](/assets/img/Breadth-first-tree.png)


## BFS의 알고리즘의 파이썬 구현 방식
BFS의 Python 구현 코드는 아래와 같습니다.
```python
def BFS(graph, start, visited):
    q = deque()
    visited[start] = True
    q.append(start)
    while 0 != len(q):
        v = q.popleft()
        for idx in graph[v]:
            if False == visited[idx]:
                q.append(idx)
                visited[idx] = True
```
* 그래프는 `List[List]` 로 구성. 
* 시간 초과를 방지하기 위해 방문 유무 필드를 노드 수만큼 만들어 준다.
* Queue에 시작 노드를 넣고, dequeue를 해서 시작노드를 빼낸다.
* 시작노드 방문 체크 후, 연결노드 방문 유무를 확인하여 처음 방문한 노드라면 큐에 넣는다.
* 해당 큐가 빌 때 까지 돈다. 큐가 비었다면 시작노드와 연결성을 가진 모든 노드는 탐색이 완료됐다는 의미.

## 주의할 점
* 모든 그래프가 그렇듯이 단방향인지, 양방향인지 문제를 잘 읽어주기.
* 방문 유무를 꼭 체크할 것. 체크 안해주면 큐에 데이터가 무한정으로 들어가 메모리가 터지거나, 중복 방문으로 시간초과가 나던가..
* 정확하게 짰음에도 시간 초과가 난다면 `Pypy3` 를 이용해 볼 것. 이래도 안되면 다른 알고리즘으로 풀어야 하는 문제인듯.